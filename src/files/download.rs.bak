use crate::common::drive_file;
use crate::common::file_tree_drive;
use crate::common::file_tree_drive::FileTreeDrive;
use crate::common::hub_helper;
use crate::common::md5_writer::Md5Writer;
use crate::files;
use crate::files::path_utils;
use crate::hub::Hub;
use async_recursion::async_recursion;
use futures::stream::StreamExt;
use google_drive3::hyper;
use human_bytes::human_bytes;
use std::error;
use std::fmt::Display;
use std::fmt::Formatter;
use std::fs;
use std::fs::File;
use std::io;
use std::io::BufReader;
use std::io::Read;
use std::io::Write;
use std::path::PathBuf;

pub struct Config {
    pub file_id: String,
    pub path: Option<String>,
    pub existing_file_action: ExistingFileAction,
    pub follow_shortcuts: bool,
    pub download_directories: bool,
    pub destination: Destination,
}

impl Config {
    async fn resolve_file_id(&self, hub: &Hub) -> Result<String, Error> {
        if let Some(path) = &self.path {
            let file = path_utils::resolve_path(hub, path)
                .await
                .map_err(Error::ResolvePath)?;
            Ok(file.id.unwrap_or_default())
        } else {
            Ok(self.file_id.clone())
        }
    }
    
    fn canonical_destination_root(&self) -> Result<PathBuf, Error> {
        match &self.destination {
            Destination::CurrentDir => {
                let current_path = PathBuf::from(".");
                let canonical_current_path = current_path
                    .canonicalize()
                    .map_err(|err| Error::CanonicalizeDestinationPath(current_path.clone(), err))?;
                Ok(canonical_current_path)
            }
            Destination::Path(path) => {
                // Check if the path is a directory or a file path
                if path.exists() {
                    // If it exists, it should be a directory
                    if !path.is_dir() {
                        // If it's a file, return its parent directory
                        if let Some(parent) = path.parent() {
                            if !parent.exists() {
                                // Create parent directories if they don't exist
                                fs::create_dir_all(parent)
                                    .map_err(|err| Error::CreateFile(err))?;
                            }
                            
                            let canonical_parent = parent
                                .canonicalize()
                                .map_err(|err| Error::CanonicalizeDestinationPath(parent.to_path_buf(), err))?;
                            
                            return Ok(canonical_parent);
                        } else {
                            return Err(Error::DestinationPathNotADirectory(path.clone()));
                        }
                    }
                    
                    // It's a directory that exists
                    let canonical_path = path
                        .canonicalize()
                        .map_err(|err| Error::CanonicalizeDestinationPath(path.clone(), err))?;
                    
                    Ok(canonical_path)
                } else {
                    // Path doesn't exist
                    // Check if it has an extension (likely a file path)
                    if path.extension().is_some() {
                        // It's probably a file path, get its parent directory
                        if let Some(parent) = path.parent() {
                            // Create parent directories if they don't exist
                            fs::create_dir_all(parent)
                                .map_err(|err| Error::CreateFile(err))?;
                            
                            let canonical_parent = parent
                                .canonicalize()
                                .map_err(|err| Error::CanonicalizeDestinationPath(parent.to_path_buf(), err))?;
                            
                            return Ok(canonical_parent);
                        }
                    }
                    
                    // It's a directory path that doesn't exist, create it
                    fs::create_dir_all(path)
                        .map_err(|err| Error::CreateFile(err))?;
                    
                    let canonical_path = path
                        .canonicalize()
                        .map_err(|err| Error::CanonicalizeDestinationPath(path.clone(), err))?;
                    
                    Ok(canonical_path)
                }
            }
            Destination::Stdout => Err(Error::StdoutNotValidDestination),
        }
    }

#[derive(Debug, Clone)]
pub enum Destination {
    CurrentDir,
    Path(PathBuf),
    Stdout,
}

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ExistingFileAction {
    Abort,
    Overwrite,
}

#[async_recursion]
pub async fn download(config: Config) -> Result<(), Error> {
    let hub = hub_helper::get_hub().await.map_err(Error::Hub)?;

    // Check if this is a wildcard path download
    if let Some(path) = &config.path {
        if path.contains('*') {
            return download_wildcard(&hub, path, &config).await;
        }
    }

    // Resolve file ID from path if provided
    let file_id = config.resolve_file_id(&hub).await?;

    // Get file metadata
    let file = files::info::get_file(&hub, &file_id)
        .await
        .map_err(Error::GetFile)?;

    // If file is a shortcut and follow_shortcuts is enabled, resolve the shortcut
    let file = if config.follow_shortcuts && drive_file::is_shortcut(&file) {
        let target_id = file
            .shortcut_details
            .as_ref()
            .and_then(|details| details.target_id.clone())
            .ok_or(Error::ShortcutMissingTargetId)?;

        files::info::get_file(&hub, &target_id)
            .await
            .map_err(Error::GetFile)?
    } else {
        file
    };

    // If file is a folder and download_directories is enabled, download the folder
    if drive_file::is_directory(&file) {
        if config.download_directories {
            return download_directory(&hub, &file, &config).await;
        } else {
            return Err(Error::IsDirectory(file.name.unwrap_or_default()));
        }
    }

    // Download the file
    download_regular(&hub, &file, &config).await
}

/// Download files matching a wildcard pattern
async fn download_wildcard(hub: &Hub, path: &str, config: &Config) -> Result<(), Error> {
    // Resolve wildcard path to get matching files
    let files = path_utils::resolve_wildcard_path(hub, path)
        .await
        .map_err(Error::ResolvePath)?;
    
    println!("Found {} files matching pattern", files.len());
    
    let mut success_count = 0;
    let mut error_count = 0;
    
    for file in files {
        let file_name = file.name.clone().unwrap_or_default();
        
        // Create a new config for this specific file
        let file_config = Config {
            file_id: file.id.clone().unwrap_or_default(),
            path: None,
            existing_file_action: config.existing_file_action.clone(),
            follow_shortcuts: config.follow_shortcuts,
            download_directories: config.download_directories,
            destination: config.destination.clone(),
        };
        
        // If file is a folder and recursive flag is not set, skip it
        if drive_file::is_directory(&file) && !config.download_directories {
            println!("Skipping directory: {}", file_name);
            continue;
        }
        
        // Download the file
        match if drive_file::is_directory(&file) {
            download_directory(hub, &file, &file_config).await
        } else {
            download_regular(hub, &file, &file_config).await
        } {
            Ok(_) => {
                success_count += 1;
            }
            Err(e) => {
                eprintln!("Error downloading {}: {}", file_name, e);
                error_count += 1;
            }
        }
    }
    
    println!("Downloaded {} files successfully, {} errors", success_count, error_count);
    
    if error_count > 0 && success_count == 0 {
        Err(Error::AllDownloadsFailed)
    } else {
        Ok(())
    }
}

pub async fn download_regular(
    hub: &Hub,
    file: &google_drive3::api::File,
    config: &Config,
) -> Result<(), Error> {
    // Use the file ID from the file object, not from the config
    // This ensures we use the resolved ID when path is provided
    let file_id = file.id.clone().unwrap_or_default();
    let body = download_file(&hub, &file_id)
        .await
        .map_err(Error::DownloadFile)?;

    match &config.destination {
        Destination::Stdout => {
            // fmt
            save_body_to_stdout(body).await?;
        }

        _ => {
            let file_name = file.name.clone().unwrap_or_else(|| "unknown_file".to_string());
            
            // Check if the destination is a file path (has extension or ends with a specific filename)
            let abs_file_path = match &config.destination {
                Destination::Path(path) if path.extension().is_some() || !path.exists() || !path.is_dir() => {
                    // If the path has an extension or doesn't exist, treat it as a file path
                    path.clone()
                },
                _ => {
                    // Otherwise, join the file name to the destination directory
                    let root_path = config.canonical_destination_root()?;
                    root_path.join(&file_name)
                }
            };

            println!("Downloading {} to {}", file_name, abs_file_path.display());
            save_body_to_file(body, &abs_file_path, file.md5_checksum.clone()).await?;
            println!("Successfully downloaded {}", file_name);
        }
    }

    Ok(())
}

pub async fn download_directory(
    hub: &Hub,
    file: &google_drive3::api::File,
    config: &Config,
) -> Result<(), Error> {
    let tree = FileTreeDrive::from_file(&hub, &file)
        .await
        .map_err(Error::CreateFileTree)?;

    let tree_info = tree.info();

    println!(
        "Found {} files in {} directories with a total size of {}",
        tree_info.file_count,
        tree_info.folder_count,
        human_bytes(tree_info.total_file_size as f64)
    );

    let root_path = config.canonical_destination_root()?;

    for folder in &tree.folders() {
        let folder_path = folder.relative_path();
        let abs_folder_path = root_path.join(&folder_path);

        println!("Creating directory {}", folder_path.display());
        fs::create_dir_all(&abs_folder_path)
            .map_err(|err| Error::CreateFile(err))?;

        for file in folder.files() {
            let file_path = file.relative_path();
            let abs_file_path = root_path.join(&file_path);

            if local_file_is_identical(&abs_file_path, &file) {
                continue;
            }

            let body = download_file(&hub, &file.drive_id)
                .await
                .map_err(Error::DownloadFile)?;

            println!("Downloading file '{}'", file_path.display());
            save_body_to_file(body, &abs_file_path, file.md5.clone()).await?;
        }
    }

    println!(
        "Downloaded {} files in {} directories with a total size of {}",
        tree_info.file_count,
        tree_info.folder_count,
        human_bytes(tree_info.total_file_size as f64)
    );

    Ok(())
}

pub async fn download_file(hub: &Hub, file_id: &str) -> Result<hyper::Body, google_drive3::Error> {
    let (response, _) = hub
        .files()
        .get(file_id)
        .supports_all_drives(true)
        .param("alt", "media")
        .add_scope(google_drive3::api::Scope::Full)
        .doit()
        .await?;

    Ok(response.into_body())
}

#[derive(Debug)]
pub enum Error {
    Hub(hub_helper::Error),
    GetFile(google_drive3::Error),
    DownloadFile(google_drive3::Error),
    CreateFile(io::Error),
    WriteChunk(io::Error),
    ReadChunk(hyper::Error),
    RenameFile(io::Error),
    FileExists(PathBuf),
    IsDirectory(String),
    Md5Mismatch { expected: String, actual: String },
    CreateFileTree(file_tree_drive::Error),
    DestinationPathDoesNotExist(PathBuf),
    DestinationPathNotADirectory(PathBuf),
    CanonicalizeDestinationPath(PathBuf, io::Error),
    MissingShortcutTarget,
    ShortcutMissingTargetId,
    IsShortcut(String),
    StdoutNotValidDestination,
    ResolvePath(path_utils::PathResolutionError),
    AllDownloadsFailed,
    MissingFileName,
    CreateDirectory(PathBuf, io::Error),
    CopyFile(io::Error),
}

impl error::Error for Error {}

impl Display for Error {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::Hub(err) => write!(f, "{}", err),
            Error::GetFile(err) => write!(f, "Failed getting file: {}", err),
            Error::DownloadFile(err) => write!(f, "Failed to download file: {}", err),
            Error::MissingFileName => write!(f, "File does not have a name"),
            Error::FileExists(path) => write!(
                f,
                "File '{}' already exists, use --overwrite to overwrite it",
                path.display()
            ),
            Error::IsDirectory(name) => write!(
                f,
                "'{}' is a directory. Use --recursive to download directories.",
                name
            ),
            Error::Md5Mismatch { expected, actual } => {
                // fmt
                write!(
                    f,
                    "MD5 mismatch, expected: {}, actual: {}",
                    expected, actual
                )
            }
            Error::CreateFile(err) => write!(f, "Failed to create file: {}", err),
            Error::CreateDirectory(path, err) => write!(
                f,
                "Failed to create directory '{}': {}",
                path.display(),
                err
            ),
            Error::CopyFile(err) => write!(f, "Failed to copy file: {}", err),
            Error::RenameFile(err) => write!(f, "Failed to rename file: {}", err),
            Error::ReadChunk(err) => write!(f, "Failed read from stream: {}", err),
            Error::WriteChunk(err) => write!(f, "Failed write to file: {}", err),
            Error::CreateFileTree(err) => write!(f, "Failed to create file tree: {}", err),
            Error::DestinationPathDoesNotExist(path) => {
                write!(f, "Destination path '{}' does not exist", path.display())
            }
            Error::DestinationPathNotADirectory(path) => {
                write!(
                    f,
                    "Destination path '{}' is not a directory",
                    path.display()
                )
            }
            Error::CanonicalizeDestinationPath(path, err) => write!(
                f,
                "Failed to canonicalize destination path '{}': {}",
                path.display(),
                err
            ),
            Error::MissingShortcutTarget => write!(f, "Shortcut is missing target"),
            Error::ShortcutMissingTargetId => write!(f, "Shortcut is missing target id"),
            Error::IsShortcut(name) => write!(
                f,
                "'{}' is a shortcut, use --follow-shortcuts to download the file it points to",
                name
            ),
            Error::StdoutNotValidDestination => write!(
                f,
                "Cannot use stdout as destination when downloading a directory"
            ),
            Error::ResolvePath(err) => write!(f, "Failed to resolve path: {}", err),
            Error::AllDownloadsFailed => write!(f, "All downloads failed"),
            Error::MissingFileName => write!(f, "Missing file name"),
            Error::CreateDirectory(path, err) => write!(f, "Failed to create directory '{}': {}", path.display(), err),
            Error::CopyFile(err) => write!(f, "Failed to copy file: {}", err),
        }
    }
}

pub async fn save_body_to_file(
    mut body: hyper::Body,
    file_path: &PathBuf,
    expected_md5: Option<String>,
) -> Result<(), Error> {
    // Create temporary file
    let tmp_file_path = file_path.with_extension("incomplete");
    let file = File::create(&tmp_file_path).map_err(Error::CreateFile)?;

    // Wrap file in writer that calculates md5
    let mut writer = Md5Writer::new(file);

    // Read chunks from stream and write to file
    while let Some(chunk_result) = body.next().await {
        let chunk = chunk_result.map_err(Error::ReadChunk)?;
        writer.write_all(&chunk).map_err(Error::WriteChunk)?;
    }

    // Check md5
    err_if_md5_mismatch(expected_md5, writer.md5())?;

    // Rename temporary file to final file
    fs::rename(&tmp_file_path, &file_path).map_err(Error::RenameFile)
}

// TODO: move to common
pub async fn save_body_to_stdout(mut body: hyper::Body) -> Result<(), Error> {
    let mut stdout = io::stdout();

    // Read chunks from stream and write to stdout
    while let Some(chunk_result) = body.next().await {
        let chunk = chunk_result.map_err(Error::ReadChunk)?;
        stdout.write_all(&chunk).map_err(Error::WriteChunk)?;
    }

    Ok(())
}

fn err_if_file_exists(file: &google_drive3::api::File, config: &Config) -> Result<(), Error> {
    let file_name = file.name.clone().ok_or(Error::MissingFileName)?;

    let file_path = match &config.destination {
        Destination::CurrentDir => Some(PathBuf::from(".").join(file_name)),
        Destination::Path(path) => Some(path.join(file_name)),
        Destination::Stdout => None,
    };

    match file_path {
        Some(path) => {
            if path.exists() && config.existing_file_action == ExistingFileAction::Abort {
                Err(Error::FileExists(path.clone()))
            } else {
                Ok(())
            }
        }

        None => {
            // fmt
            Ok(())
        }
    }
}

fn err_if_directory(file: &google_drive3::api::File, config: &Config) -> Result<(), Error> {
    if drive_file::is_directory(file) && !config.download_directories {
        let name = file
            .name
            .as_ref()
            .map(|s| s.to_string())
            .unwrap_or_default();
        Err(Error::IsDirectory(name))
    } else {
        Ok(())
    }
}

fn err_if_shortcut(file: &google_drive3::api::File, config: &Config) -> Result<(), Error> {
    if drive_file::is_shortcut(file) && !config.follow_shortcuts {
        let name = file
            .name
            .as_ref()
            .map(|s| s.to_string())
            .unwrap_or_default();
        Err(Error::IsShortcut(name))
    } else {
        Ok(())
    }
}

fn err_if_shortcut_target_is_missing(target_id: &Option<String>) -> Result<(), Error> {
    if target_id.is_none() {
        Err(Error::MissingShortcutTarget)
    } else {
        Ok(())
    }
}

fn err_if_md5_mismatch(expected: Option<String>, actual: String) -> Result<(), Error> {
    let is_matching = expected.clone().map(|md5| md5 == actual).unwrap_or(true);

    if is_matching {
        Ok(())
    } else {
        Err(Error::Md5Mismatch {
            expected: expected.unwrap_or_default(),
            actual,
        })
    }
}

fn local_file_is_identical(path: &PathBuf, file: &file_tree_drive::File) -> bool {
    if path.exists() {
        let file_md5 = compute_md5_from_path(path).unwrap_or_else(|err| {
            eprintln!(
                "Warning: Error while computing md5 of '{}': {}",
                path.display(),
                err
            );

            String::new()
        });

        file.md5.clone().map(|md5| md5 == file_md5).unwrap_or(false)
    } else {
        false
    }
}

fn compute_md5_from_path(path: &PathBuf) -> Result<String, io::Error> {
    let input = File::open(path)?;
    let reader = BufReader::new(input);
    compute_md5_from_reader(reader)
}

fn compute_md5_from_reader<R: Read>(mut reader: R) -> Result<String, io::Error> {
    let mut context = md5::Context::new();
    let mut buffer = [0; 4096];

    loop {
        let count = reader.read(&mut buffer)?;
        if count == 0 {
            break;
        }
        context.consume(&buffer[..count]);
    }

    Ok(format!("{:x}", context.compute()))
}
